Progress Report:

Emily Fox
ef337@cam.ac.uk
Dr. Samuel Aaron
Dr. John Fawcett
Overseers

What has so far been achieved?

- Modify miniKanren
- Tried and failed original plan, how this limits the domain
- NEW stages of generation
- Example in action

During the initial stages of the project, it became clear that MiniKanren was going to need modifying for the purposes of this software since the Ruby implementation used was reasonably old and incomplete. This meant that there were unforeseen delays while I familiarised myself with the third party code enough that I could add the functionality that I needed, and be able to express those requirements concretely. In the end there were two things I needed that weren't already supported: a `project' constraint function and support for hash maps as variables. Therefore the project did get delayed in the first few weeks due to a larger learning curve than expected. However, after meeting with TITLE William Byrd and my supervisor, `project' was sorted, and then I later implemented the hash compatibility in my own time. A pull request will be issued soon to get these changes into the main branch of MiniKanren for Ruby on GitHub.

Once MiniKanren has been modified, the actual canon generation could begin. The original plan was to have logic variables representing notes and then add constraints between these about what would sound good together and let it generate solutions that fitted these. However, this approach failed for a few reasons. Firstly, this method essentially boiled down to the Generate-And-Test logic programming paradigm which, when considering the number of different combinations even for a short 3 bar piece with 4 notes in each bar, turned out to be wildly inefficient, espcecially when lots of the logic relied heavily on the `project' function which in essense performs all the substitions for the variables each time it is run. Not only this, but when I did manage to get it to terminate, the results generated were very musically boring, with the same pitch for each note, or close to that. Although these are solutions, and constraints could be added to eliminate this problem, we would then run into similar problems. It turned out that an approach which had far more music theory at its heart was required.

The technique I have now adopted is one that relies primarily on a chord progression with the same number of chords as beats in the bar. This is generated by picking random chords for each beat, except the final two where we will have a cadence- either perfect or plagal- to end the piece. This is then passed into some logic that will generate a skeleton for the canon which consists of a key note for every beat. Broadly, this is found by adding constraints that each note must belong to the chord that corresponds to that beat, so that overlapping notes will belong to the same chord and we get `nice' sounding interaction between voices. Also, we add the constraint that they must be different from each overlapping note (so that passing notes don't clash too much) and they can only be a certain distance from the one after it (to affect how much the music `jumps' around).

Version 1.0 of the canon generator is now complete. The code so far conforms to the following specification:

How does progress compare to the original schedule?

The project is largely to schedule, including implementing the extension which allows the music to be exported into Lilypond to enable it to be typeset. The only change to the schedule that needs to be implemented is that the work that was originally planned for the 15th-28th January must be moved to the following two weeks where there was originally buffer time. This has been accounted for in the updated timetable shown at the end of this document.
